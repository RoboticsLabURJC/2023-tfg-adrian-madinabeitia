---
title: "Semana 5 - Drone en simulación y pytorch"
categories:
  - Weekly Log
tags:
  - ROS2
  - Aerostack2
  - Machine Learning
  - Neural Networks
  - pyTorch
---

En esta semana nos dedicamos a conseguir "dominar" aerostack2 e implementar nuestra primera red neuronal.


## Index
* [Aerostac2](#aerostack-2)
	* [Px4 autopilot](#px4-autopilot)
	* [Circuit launcher](#circuit-launcher)
	* [Problemas encontrados](#problemas-encontrados)
	* [Cerrar sesión tmux](#cerrar-sesión-tmux)
	* [Follow line launcher](#follow-line-launcher)

---
---

## Aerostack 2
Se cambió el launcher y en vez de ejecutar todos los componentes de aerostack2 en la misma terminal, se creó una sesión de tmux para tener cada componente en una terminal de una manera limpia. Al lanzar todo con nuestra configuración anterior de simulador me di cuenta que no se conectaba el drone. 

### Px4 autopilot
Investigando descubrí que en el paquete de ejemplo se lanzaba el autopilot de px4 junto a gazebo. Lo que hice para probar si era eso fué hacer 1 launcher que parseara los parámetros de world.json para que en "world", estubiera la ruta del mundo ocean_simulation, además de añadir el px4 dual cam. Esto se lanazaba con un script en la ruta:  ~/workspace/install/as2_gazebo_classic_assets/share/as2_gazebo_classic_assets/scripts. Sin embargo el mundo se lanzaba vacío por el siguiente error: 

run_sitl.sh:

```bash
	# Check if world file exist, else look for world
	if [[ -f $world ]]; then
		world_path="$world"
	else
		target="${world}.world"
		world_path="$(get_path ${target} ${GAZEBO_RESOURCE_PATH})"
	fi

	# Check if world_path exist, else empty
	if [[ -d $world_path ]]; then
		world_path="${world_path}/${target}"
	else
		echo "empty world, setting empty.world as default"
		world_path="${src_path}/Tools/simulation/gazebo-classic/sitl_gazebo/worlds/empty.world"
	fi
```
Primero comprueba que $world sea un archivo, si es así pasará a la parte del directorio, pero al hacer la segunda comprobación con el parámetro -d comprueba que exista un directorio, al ser un archivo dará false y la dirección a empty y se lanzará el mundo vacío. 

Si se pasa solo el directorio se añadirá solo .world a la ruta y esta será incorrecta.

Desde mi punto de vista lo mas sencillo es hacer que se le pase al script el .world directo, asñi será mas sencillo de ejecutar.

run_sitl.sh:
```bash
	# Check if world file exist, else look for world
	if [[ -f $world ]]; then
		world_path="$world"
	else
		echo "empty world, setting empty.world as default"
		world_path="${world_path}"
	fi
```

### Circuit launcher
Una vez solucionado esto, se consiguió lanzar la simulación del ejercicio "rescue people" por lo que se prepraró el launcher para el circuito.

#### Problemas encontrados
* No se consiguió pasar de formato **LaunchConfiguration** a String por lo que las constantes del launcher se declararon como globales. 

* El name space de las cámaras del drone se cambiaba, esto era por que dependía de la variable de entorno **$AEROSTACK2_SIMULATION_DRONE_ID** por lo que esta se cambió en el **executeProcess** que lanza el simulador.

* Al parsear las coordenadas de este mapa el estado **arm** del drone tiende a fallar mas pero tras varios reintentos automáticos alcanza el estado y comienza el despegue, la razón es desconocida.

#### Cerrar sesión tmux
Cada vez que hacía una prueba, había que cerrar la sesión de tmux ya que esta se quedaba abierta, busqué una forma de ejecutar comandos directos en el launcher cuando se detectará **Ctrl + C** pero no lo conseguí. 

Sin embargo encontré una forma de ejecutar un script de python dentro de launcher en el siguiente [link](https://answers.ros.org/question/376588/execute-another-process-on-process-exit/) por lo que encontré una manera de llamar a un script al cerrar el simulador y así cerrar todo el programa con un Ctrl+C. El script para cerrar la sesión se añadió a la carpeta utils.

### Follow line launcher
Se creó un nodo que obtiene la imagen de la cámara frontal del drone y la filtra para obtener la línea. Este mismo la publica en un topic y posteriormente el nodo de control del drone obtendrá esta imagen y comandará las velocidades como en el ejercico del coche. Sin embargo la implementación de este último nodo se dejó para la semana siguiente.


## Pytorch 
Nuestro objetivo de esta semana fué conseguir entrenar el modelo pilotNet estudiado la semana pasada. Cinvinando la [documentación de pytorch](https://pytorch.org/tutorials/beginner/basics/buildmodel_tutorial.html) con el siguiente [ejemplo](https://github.com/alisnichenko/pilotnet-pytorch/blob/master/model.py) de modelo, hicimos la primera aproximación. A la red neuronal de ejemplo le quitamos 1 capa fully-conected (**nn.Linear(1152, 1164)**) y le añadimos la capa inicial de normalización a los 3 canales **nn.BatchNorm2d(3)**

### nn.Conv2d(c_in, c_out, kernel, stride):

<!-- Insertar imagen de pilot net -->

### Estudio en profundidad
Además se repasó el funcionamiento interno de las redes convolucoinales:

#### Stride

#### Padding

#### Max poling

#### Stacking

#### Función de activación ReLU
Función de activación no lineal donde la salida es 0 si la entrada es menor que 0 y si la entrada es mayor que cero se quedará su valor. g(x) = max(0, x)

<!-- Imagen Relu -->